1: 这是一个从网上拷贝的代码，是熟悉和掌握epoll入门的好样例：（https://blog.csdn.net/buknow/article/details/107018954）

2: 我已经将改样例的客户端链接改成了非阻塞的模式。

3: ？测试Epoll_Server 里的msg 的大小从1024改成了10后发现，read 函数接收client 返回来的数据后会再次执行epoll 里的水平触发，也就是代表read没有一次读完所有数据，追查其原因是client在write时指定size=1024，即时你传输的msg="1111"四个字符write(i_sockfd, msg, 1024)也会给server发送1024个字符过去，而read函数读取到第一个字符串"1111"后因为读取到了字符串结尾标识所以么有往后继续读取，所以后面的1020个字符还在缓冲区里，等epoll二次水平触发时就会出现再次读取的情况，基于以上问题，我将client的代码做了调整， write(i_sockfd, t_msg.c_str(), t_msg.size()) 这样改完，字符串长度时多少就发送多少字符给server后就不会有问题了。

4: ？测试Epoll_Client 时，read也可能一次读取不完所有数据，改进后进行了循环读取，直到没有数据，这样怎么才知道数据没有读完呢，简单做了个设计就是读取报错3次以上都没有取到新数据意味着读取完了，这里需要注意一个点，server 执行write数据时，如果多次write的字符串后面都带了一个'\0'，client 读取数据时如果一次性没有读取完所有数据，比如server发了10个字符串+'\0'结束，client 读取了7个字符输出后，再次读取的时候会出现123'\0'567'\0'这种情况，输出时发现只读到了前三个字符，实际已经读取了7个字符进来。所有server 进行write时如果需要write的数据没有写完，write的字符串后面注意不要添加'\0' 返回。
